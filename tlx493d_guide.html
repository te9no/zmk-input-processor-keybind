<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZMKドライバ開発マスターガイド：磁気センサーで空中マウスを作る全記録</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #fdfdfd;
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
            line-height: 1.2;
        }
        h1 {
            font-size: 2.5em;
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h2 {
            font-size: 2em;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-top: 40px;
            margin-bottom: 20px;
        }
        h3 {
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        h4 {
            font-size: 1.2em;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        p {
            margin-bottom: 1em;
        }
        ul {
            padding-left: 20px;
            margin-bottom: 1em;
        }
        li {
            margin-bottom: 0.5em;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: "Courier New", Courier, monospace;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
        }
        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 40px 0;
        }
        .section-intro {
            font-style: italic;
            color: #555;
            border-left: 3px solid #3498db;
            padding-left: 15px;
        }
    </style>
</head>
<body>

    <h1>ZMKドライバ開発マスターガイド：磁気センサーで空中マウスを作る全記録</h1>

    <h2>【まえがき】</h2>
    <p>ようこそ、ZMKの奥深い世界へ。</p>
    <p>この資料は、単なるキーボードファームウェアの解説書ではありません。一つのアイデアが、どのようにして具体的な「モノ」として形になっていくのか、その設計、実装、そして数々の困難なデバッグの過程を、生々しく記録したドキュメンタリーです。</p>
    <p>読者の皆さんは、3D磁気センサー「TLX493D」を使って空中マウスを開発するというプロジェクトを、開発者と共に追体験します。フリーズ、無反応、予期せぬ挙動…次々と襲いかかる問題に対し、ログを読み解き、仮説を立て、コードを修正していく。その試行錯誤の全記録がここにあります。</p>
    <p>この旅を終える頃には、あなたはZMKドライバ開発の核心的な知識だけでなく、ソフトウェア開発における普遍的な問題解決のスキルを身につけていることでしょう。さあ、ハンダごてとエディタを手に、冒険を始めましょう。</p>

    <hr>

    <h2>第一部：構想と設計 - アイデアをカタチにする設計図</h2>
    <p class="section-intro">すべての偉大なプロダクトは、一枚の優れた設計図から生まれます。この部では、私たちのプロジェクト「空中マウス」を実現するための土台を築きます。なぜこの挑戦が面白いのかという動機から始まり、最適なハードウェアを選び抜き、そしてZMK/Zephyrという強力なフレームワークの作法に則って、堅牢なソフトウェアの設計図を描き上げます。ここでの深い理解が、後の実装とデバッグの成功を左右する鍵となります。</p>

    <h3>第1章：なぜ今、ZMKでポインティングデバイスなのか？</h3>
    <p>自作キーボードの魅力は、もはや単なるタイピング効率の追求だけにとどまりません。キーマップを自由に書き換え、レイヤー機能を駆使し、思い通りのショートカットを配置する。そのカスタマイズの旅は、自然と次の領域へと向かいます。それは、キーボードという「入力の司令塔」に、あらゆる機能を統合することです。</p>
    <p>その中でも特に重要なのが、ポインティングデバイスの統合です。タイピングのホームポジションから手を離し、マウスやトラックパッドに手を伸ばす、そのわずか数秒の動作。この小さな断絶が、私たちの集中力や思考のフローを妨げる大きな要因となります。もし、キーボードから手を離さずにマウスカーソルを操作できたなら、作業効率はどれほど向上するでしょうか。</p>
    <p>今回のプロジェクトは、そのコンセプトをさらに一歩推し進める野心的な挑戦です。物理的なボールやパッドではなく、指先の磁石の動きを3Dセンサーで捉え、カーソルを操作する「空中マウス」。このドライバが目指すのは、センサーから読み取った磁場データをZMKのポインティングデバイス機能に変換し、マウスカーソルの移動を可能にすることです。これにより、デスク上での操作はもちろん、プレゼンテーションやリラックスした姿勢でのPC利用など、まったく新しいユースケースを切り開く可能性を秘めています。</p>

    <h3>第2章：相棒選び - 3D磁気センサー「TLX493D」</h3>
    <p>壮大な目標を実現するには、信頼できる相棒が不可欠です。今回のプロジェクトで、数あるセンサーの中から私たちが選んだのは、Infineon社が製造する TLX493D 3D磁気センサーです。</p>
    <p>この小さなチップは、X、Y、Zという3次元空間における磁場の強さと方向を、非常に高い精度で測定する能力を持っています。私たちがこのセンサーを選んだ理由は、主に3つあります。</p>
    <ul>
        <li><strong>卓越した3D検出能力:</strong> X軸とY軸の磁場変化をマウスカーソルの左右・上下の動きに対応させるのはもちろん、Z軸（センサーへの接近・離反）のデータを、将来的にスクロールやクリックといった追加機能に割り当てる大きな可能性を秘めています。一つのセンサーで、豊かな表現力を実現できるのです。</li>
        <li><strong>標準的なI2Cインターフェース:</strong> センサーとマイクロコントローラ（キーボードの頭脳）との通信には、I2Cプロトコルを採用します。I2Cは、多くのマイコンで標準サポートされており、比較的少ないピン数（2本）で接続できるため、ハードウェアの設計をシンプルに保つことができます。</li>
        <li><strong>ZMK/Zephyrとの親和性:</strong> ZMKの土台となっているリアルタイムOS「Zephyr」は、標準で強力なI2Cドライバサポートを備えています。これは、私たちがセンサー固有のロジック開発に集中できることを意味し、開発のハードルを大きく下げてくれます。</li>
    </ul>
    <p>このTLX493Dと共に、私たちは磁場の変化をカーソルの軌跡へと変換する旅に出ます。</p>

    <h3>第3章：ドライバの設計図 - ZMK/Zephyrの世界観を理解する</h3>
    <p>センサーを選んだら、次はそのセンサーをZMKの世界にどうやって組み込むかを考えます。ZMK/Zephyrには、ハードウェアを追加するための洗練された「作法」が存在します。この作法に従うことで、私たちのコードはフレームワークの一部として、美しく、かつ効率的に動作します。</p>
    <ul>
        <li><strong>デバイスツリー (.overlay):</strong> ZMKに「新しいハードウェア」を紹介する住民票のような仕組み。センサーがどのI2Cバスに、どのアドレスで接続されているかを記述します。</li>
        <li><strong>I2C通信:</strong> マイコンとセンサーが会話するためのプロトコル（共通言語）です。</li>
        <li><strong>Input API:</strong> センサーが翻訳した「マウスの動き」を、ZMK本体に報告するための公式ルート。<code>input_report_rel</code>といった関数が用意されています。</li>
        <li><strong>Kconfig:</strong> ユーザーがファームウェアの機能をON/OFFしたり、パラメータ（感度など）を変更したりするための設定スイッチです。</li>
        <li><strong>ワークキュー (k_work_delayable):</strong> ドライバのメインループ。リアルタイム性を損なわずに、定期的な処理（センサー監視など）を実行するための賢い仕組みです。</li>
    </ul>

    <hr>

    <h2>第二部：コード完全解説 - tlx493d_1.cの歩き方</h2>
    <p class="section-intro">完成したドライバコードを、一行ずつ丁寧に解剖します。なぜこの変数が存在するのか、このビット演算が何をしているのか。魔法のように見えるコードのロジックを、誰にでも分かるように解説します。</p>
    
    <h3>Cコード解説：TLX493Dドライバの処理フロー</h3>
    <p>このコードは、TLX493D 3D磁気センサーをZMKファームウェアで動かすためのドライバです。全体の流れは、<strong>「①初期化の儀式」を行い、その後「②定期的な見回り」</strong>を繰り返す、というシンプルな構造になっています。</p>

    <h4>全体の流れ</h4>
    <ul>
        <li><strong>ZMK起動時:</strong> ZMKが起動すると、デバイスツリーに記述されたこのドライバの<code>tlx493d_init</code>関数が一度だけ呼び出されます。</li>
        <li><strong>初期化 (<code>tlx493d_init</code>):</strong> センサーとの通信準備を整え、正常に動作するかを確認します。</li>
        <li><strong>定期処理の予約:</strong> 初期化の最後に、定期的にセンサーの状態をチェックする「見回り役」の仕事 (<code>tlx493d_work_handler</code>) をスケジュールします。</li>
        <li><strong>ループ処理:</strong> あとはZMKが動いている間、この「見回り役」が指定された間隔（例: 10ミリ秒ごと）で呼び出され、マウスの動きを報告し続けます。</li>
    </ul>
    <p>それでは、主要な関数の動きを詳しく見ていきましょう。</p>

    <h4>1. tlx493d_init （初期化の儀式）</h4>
    <p>この関数は、ドライバがZMKにロードされたときに最初に呼ばれる、最も重要な関数です。センサーを使える状態にするための準備をすべてここで行います。</p>
    <p><strong>役割:</strong> センサーとの通信路を確立し、正常に動作するよう設定し、定期的なデータ読み取りを開始させる。</p>
    <p><strong>擬似コードで見る <code>tlx493d_init</code> の流れ:</strong></p>
    <pre>
関数 tlx493d_init(デバイス):
  // STEP 1: 基本的な準備
  1. ドライバ自身のデバイス情報や変数を準備する
  2. センサーとの通信に使うI2Cバスが利用可能かチェックする
     もし使えなければ、エラーを記録して処理を中断する

  // STEP 2: センサーを目覚めさせる
  3. センサーの初期化シーケンス `tlv493d_initialize_sensor` を実行する
     もし失敗すれば、エラーを記録して処理を中断する

  // STEP 3: 最初の読み取りと定期処理の開始
  4. 最初のセンサー値を読み込む `tlx493d_read_sensor_data`
     これにより、起動直後にカーソルが意図せずジャンプするのを防ぐ
  5. 読み取った最初の値を「前回の値」として保存しておく (`prev_x`, `prev_y`)

  // STEP 4: 「見回り役」に仕事を依頼
  6. 定期的に呼ばれる関数 `tlx493d_work_handler` の準備をする
  7. `tlx493d_work_handler` に「最初の見回り」を依頼（スケジュール）する

  8. "初期化に成功しました" というメッセージを記録して、無事終了
    </pre>

    <h4>2. tlv493d_initialize_sensor （センサーを目覚めさせる手順）</h4>
    <p><code>init</code>関数から呼ばれる、センサー固有の初期化処理です。データシートに記載された手順に従って、センサーをリセットし、最適な動作モードに設定します。</p>
    <p><strong>役割:</strong> センサーをリセットし、高速かつ継続的に測定できるモードに設定する。</p>
    <p><strong>擬似コードで見る <code>tlv493d_initialize_sensor</code> の流れ:</strong></p>
    <pre>
関数 tlv493d_initialize_sensor(デバイス):
  1. 念のため、センサーに「復帰コマンド」を送る
  2. センサーに「リセットコマンド」を送って、設定を工場出荷状態に戻す
  3. センサーが安定するまで少し待つ (10ミリ秒)
  4. 通信が確立しているか確認するため、試しにレジスタを1つ読んでみる
     もし失敗すれば、エラーを記録して処理を中断する
  5. 後で設定を書き込むために、センサー固有の「工場出荷設定値」を読み出して保存しておく
  6. センサーの動作モードを設定する:
     - 「高速モード」を有効にする
     - （ついでに）「温度測定」も有効にする
     - このとき、先ほど保存した工場出荷設定を壊さないように、設定を合成して書き込む
  7. "センサーの初期化が完了しました" というメッセージを記録して終了
    </pre>

    <h4>3. tlx493d_work_handler （定期的な見回り役）</h4>
    <p>このドライバのメインループです。<code>init</code>関数によってスケジュールされ、その後は自分自身で次のスケジュールを予約しながら、繰り返し実行されます。</p>
    <p><strong>役割:</strong> 定期的にセンサーデータを読み取り、前の値との差分を計算し、動きがあればZMKにマウスの移動として報告する。</p>
    <p><strong>擬似コードで見る <code>tlx493d_work_handler</code> の流れ:</strong></p>
    <pre>
関数 tlx493d_work_handler(仕事):
  // STEP 1: センサーの状態を確認
  1. センサーから現在の磁場データ(X, Y, Z)を読み込む (`tlx493d_read_sensor_data` を呼ぶ)

  // STEP 2: 動きがあったか計算・報告
  2. もしデータの読み込みに成功したら:
     a. `delta_x = 現在のX - 前回のX` を計算する
     b. `delta_y = 現在のY - 前回のY` を計算する
     c. もし `delta_x` または `delta_y` に動きがあったら:
        - ZMKのマウス機能に `input_report_rel` を使って移動量を報告する
        - このとき、ZMKの作法に従い、最後の報告で「これで一区切りです」という同期フラグ(`true`)を立てる
     d. 次の計算に備えて、現在の値を「前回の値」として保存する

  // STEP 3: 次回の見回りを予約
  3. 「(設定された時間)ミリ秒後に、また私を呼び出してください」と次の仕事をスケジュールする
    </pre>

    <h4>4. tlx493d_read_sensor_data （センサーの心の声を聴く）</h4>
    <p><code>work_handler</code>から呼ばれ、実際にセンサーとI2C通信を行って生のデータを取得し、プログラムで使える形式に変換します。</p>
    <p><strong>役割:</strong> I2C通信でセンサーから生データを取得し、それを符号付き12ビットのX, Y, Z値に変換する。デバッグ用のログも出力する。</p>
    <p><strong>擬似コードで見る <code>tlx493d_read_sensor_data</code> の流れ:</strong></p>
    <pre>
関数 tlx493d_read_sensor_data(デバイス):
  1. センサーが初期化済みか確認する。もしまだならエラーを返す
  2. I2C経由で、磁場データが格納されている6つのレジスタを一気に読み込む
     もし失敗すれば、エラーを記録して処理を中断する
  3. 読み込んだ6バイトの生データを、意味のあるX, Y, Zの数値に変換する:
     - (例: X値 = 1番目のバイトを4ビット左にずらしたもの + 2番目のバイトを4ビット右にずらしたもの)
     - このようなビット演算をX, Y, Zそれぞれで行う
  4. 【デバッグ機能】変換したX, Y, Zの値を、コンソールに数値と棒グラフで分かりやすく表示する
  5. 成功を知らせて終了
    </pre>
    <p>このコードは、ドライバの初期化から定期的なデータ監視、そしてZMKへの報告という一連の流れを、役割ごとにきれいに分割して実装しています。特に、<code>work_handler</code>が中心となってループ処理を行う構造は、ZMK/Zephyrにおけるドライバ開発の典型的なパターンです。</p>

    <hr>

    <h2>第三部：デバッグ戦記 - ヒーローはバグと戦う</h2>
    <p class="section-intro">実装の道は、バグとの戦いの連続です。この章では、実際に発生した4つの重大な問題と、その解決の過程を詳細に解説します。これは、机上の理論だけでは学べない、実践的なトラブルシューティングの記録です。</p>

    <h3>第4章：デバッグ戦記①：フリーズ地獄とk_sleepの罠</h3>
    <ul>
        <li><strong>現象:</strong> マウスセンサーを動かすとファームウェア全体がフリーズする。</li>
        <li><strong>原因:</strong> イベント処理の真っ最中に <code>k_sleep</code> で処理を「待って」いたため、システム全体が停止していた。</li>
        <li><strong>教訓:</strong> リアルタイムシステムでは「待つな」。イベントハンドラは電光石火で処理を終えなければならない。</li>
    </ul>

    <h3>第5章：デバッグ戦記②：沈黙するイベントとSTOPの罠</h3>
    <ul>
        <li><strong>現象:</strong> フリーズはしなくなったが、キー入力が全く生成されない。</li>
        <li><strong>原因:</strong> 処理対象外のイベントに対しても <code>ZMK_INPUT_PROC_STOP</code> を返し、イベントの伝播を「通行止め」にしていた。</li>
        <li><strong>教訓:</strong> イベントの流れを理解し、不要なSTOPは避ける。自分の仕事でなければ <code>ZMK_INPUT_PROC_CONTINUE</code> で次にパスを回す。</li>
    </ul>

    <h3>第6章：デバッグ戦記③：イベントの洪水とクールダウンの実装</h3>
    <ul>
        <li><strong>現象:</strong> マウスを少し動かしただけでキーが猛烈に連打され、システムが過負荷でフリーズする。</li>
        <li><strong>原因:</strong> 高頻度なセンサー入力を間引くことなく、そのままキーイベントに変換していたため、イベントの洪水が発生していた。</li>
        <li><strong>教訓:</strong> 高頻度入力には「クールダウン」が必須。一度処理したら一定時間休み、システムの負荷を調整する。</li>
    </ul>
    
    <hr>

    <h2>【あとがき】</h2>
    <p>この長い旅にお付き合いいただき、心から感謝します。このガイドを通じて最も伝えたかったことは、ソフトウェア開発とは、単にコードを書く行為ではない、ということです。それは、仮説を立て、実験し、失敗から学び、そして再び挑戦する、知的で創造的な冒険です。</p>
    <p>ここに記された知識やコードは、あくまで出発点に過ぎません。ぜひ、このガイドを片手に、あなた自身のアイデアを加え、世界に一つだけの入力デバイスを創造してください。Z軸でレイヤーを切り替える？ジェスチャーでマクロを起動する？可能性は無限です。</p>
    <p>どうか失敗を恐れず、好奇心を羅針盤に、コーディングの海へと漕ぎ出してください。あなたの次なる作品に出会える日を、心から楽しみにしています。</p>
    <p>Happy Hacking!</p>

</body>
</html>